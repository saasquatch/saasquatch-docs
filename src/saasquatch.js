export const schema = `
"""
An ISO 8601 formatted string duration. e.g. "P3Y6M4DT12H30M5S"
"""
scalar IsoDuration
"""
An ISO 8601 interval. e.g. "2007-03-01T13:00:00Z/2008-05-11T15:30:00Z"
"""
scalar IsoInterval
scalar JobType
"""
A JSON schema
"""
scalar JsonSchema
"""
A 64-bit integer
"""
scalar Long
scalar PredefinedRewardType
"""
The id of RewardUnitSettings. e.g. \`t/CREDIT/u/CREDIT\` or "t/CREDIT/u/CASH/USD"
"""
scalar RewardUnitSettingsId
"""
A 3-letter ISO 4217 currency code
"""
scalar RSCurrencyCode
"""
A timestamp expressed as the number of milliseconds since epoch.
"""
scalar RSDate
"""
An abitrary JSON node
"""
scalar RSJsonNode
"""
A language-country locale pair separated by an underscore. e.g. "en_US"
"""
scalar RSLocale
"""
A relative timeframe string based on relative time. e.g. "last_7_days" or "this_year"
"""
scalar RSRelativeTimeframe
"""
A shallow JSON object
"""
scalar RSShallowMap
scalar SegmentKey
scalar SegmentOperation
scalar TranslatableAssetId
scalar TranslationInstanceId
scalar WidgetType

"""
The operations under Query are operation that are side-effect free.
"""
type Query {
  """
  The mathematic identity function. Useful for returning input variables.
  """
  identityFunction(value: RSJsonNode): RSJsonNode
  """
  Lookup a user by its id and accountId
  """
  user(accountId: String!, id: String!): User
  """
  List all the users in a tenant.

   - Can be filtered
   - Is [paginated](/pagination)
  """
  users(
    filter: UserFilterInput
    # A very inefficient query string. This should be treated as deprecated.
    query: String
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
    sortBy: [RSSortByInput!]
  ): UserList
  """
  Lookup a single Account based on ID.
  """
  account(accountId: String!): PaymentAccount
  """
  Lookup a reward by id
  """
  reward(id: ID!): FlatReward
  """
  Lookup a referral by id
  """
  referral(id: ID!): Referral
  """
  List all the referrals in a tenant.

   - Can be filtered
   - Is paginated
  """
  referrals(
    filter: ReferralFilterInput
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
    sortBy: [RSSortByInput!]
  ): ReferralList
  """
  Get information for current tenant
  """
  tenant: Tenant
  """
  Details of the current portal project in scope.
  """
  portalProject: PortalProject
  """
  The active trigger in scope. Used by the SaaSquach Program Engine.
  """
  activeProgramTrigger: ProgramTrigger
  """
  Get Maxmind geo data for an IP address
  """
  geoData(ip: String!): RSJsonNode
  """
  Generate a set of unique SaaSquach IDs for use with rewards, referrals and the Program Engine.
  """
  ids(length: Int!): [ID!]!
  """
  Returns the JSON Web Key Set for the SaaSquatch API. This is useful for validating JWT tokens and other signatures that are generated by the SaaSquatch API.

  See [RFC-7517](https://tools.ietf.org/html/rfc7517)
  """
  jwks: RSJsonNode!
  """
  Returns the current server time for the tenant in scope.

  This is useful when testing time-based programs using the time machine.
  """
  dateTime(epochMilli: RSDate, timeZone: String! = "UTC"): ZonedDateTime!
  """
  Given a currency code, returns the metadata about that currency. Useful for displaying rich information about a currency.
  """
  currency(currencyCode: RSCurrencyCode!): RSCurrency
  """
  List all currencies that SaaSquatch has metadata for.
  
   - Is paginated
  """
  currencies(limit: Int! = 20, offset: Int! = 0): RSCurrencyList!
  """
  List all programs installed in the current tenant.

   - Is paginated
   - Can be filtered
  """
  programs(
    filter: ProgramFilterInput
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
  ): ProgramList!
  """
  Lookup an individual program
  """
  program(id: ID!): Program
  """
  Get all the program templates installable for the current tenant
  """
  programTemplates: [ProgramTemplate!]!
  """
  Get the JWT token for an integration.

  Used in the SaaSquatch portal for providing authentication to the integrations connected to an account.
  """
  integrationToken(name: String!): String!
  """
  List the custom codes

   - Is paginated
   - Can be filtered by their use
  """
  customCodes(
    predefinedRewardType: PredefinedRewardType!
    used: Boolean! = false
    limit: Int! = 20
    offset: Int! = 0
  ): CustomCodeList
  """
  List all of the integrations that can be enabled in a tenant, and details about their connection status.

   - Is paginated
  """
  integrations(
    type: IntegrationType
    limit: Int! = 20
    offset: Int! = 0
  ): TenantIntegrationList!
  """
  Look up an individual Integration
  """
  integration(service: String!): TenantIntegration
  """
  Look up all the translatable assets in a Tenant. 

  Useful for internationalization (i18n). This returns a node about things that can be translated, and for each can query the Graph connections
  to retrieve the translated copies for each language.
  """
  translatableAssets: [TranslatableAsset!]!
  """
  Look up an individual translation of a translatable asset.
  """
  translationInstance(id: TranslationInstanceId!): TranslationInstance
  """
  List all the import, export and batch jobs in the tenant.

  Useful for seeing if there are any long-running jobs still active.

   - Is paginated
   - Can be filtered
  """
  jobs(
    filter: JobFilterInput
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
  ): JobList!
  """
  Lookup an individual import, export or batch job given it's ID.

  Useful for integrations and data synchronization proceses to poll for the status of a job. 
  Can also use the \`job.completed\` webhook.
  """
  job(id: ID!): Job
  jobToken(id: ID!): JobToken!
  """
  Lookup a single segment

  Useful for seeing if a segment is in use, details about it, and showing the segment metadata in the user interface.
  """
  segment(key: SegmentKey!): Segment
  """
  List all segments

  Useful for seeing which segments are in use, and details about their use.

   - Is paginated
  """
  segments(limit: Int! = 20, offset: Int! = 0): SegmentList!
  """
  List of all user metrics.

  Useful for seeing which custom fields are being automatically calculated.

   - Is paginated
  """
  userMetrics(limit: Int! = 20, offset: Int! = 0): UserMetricList!
  """
  List of all custom fields

  Useful for seeing which custom fields are currently in use, details about them, and showing that in the user interface.

   - Is paginated
  """
  customFields(limit: Int! = 20, offset: Int! = 0): CustomFieldList!
  """
  Same as mutation->logUserEvent, but it doesn't apply the side effects,
  and it returns all the side effects as a preview.

  - Useful for confirming that programs are configured as desired.
  - Useful for pre-validating data to be submitted before manually submitting data.
  """
  previewUserEvent(userEventInput: UserEventInput!): UserEventResult!
  """
  Given a User ID and Account Id, generates a non-reversible hash for GDPR opt-out tracking.
  """
  calculateUserDoNotTrackIdentifierHash(
    id: String!
    accountId: String!
  ): String!
  """
  List all users that are in the Do Not Track list, by their hashed non-reversible identifiers.
  """
  userDoNotTrackIdentifiers(
    limit: Int! = 20
    offset: Int! = 0
  ): UserDoNotTrackIdentifierList!
  """
  List all emails sent, queued or attempted by a program.

  Useful for auditing if emails were sent, their status.

   - Is paginated
   - Can be filtered
  """
  programEmailTransactions(
    filter: ProgramEmailTransactionFilterInput
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
    sortBy: [RSSortByInput!]
  ): ProgramEmailTransactionList!
  """
  List all user events

  Useful for auditing what data has been successfully recorded by SaaSquatch.

   - Is paginated
   - Can be filtered
  """
  userEvents(
    # Only one field can be filtered here
    filter: UserEventDataFilterInput!
    limit: Int! = 20
    offset: Int! = 0
    sortBy: [RSSortByInput!]
  ): UserEventDataList!
  """
  List all event types

  Useful for checking which event types are currently in use, and details about those events.

   - Is paginated
  """
  userEventKeys(limit: Int! = 20, offset: Int! = 0): UserEventKeyList!
  """
  Preview the moderation a set of graph nodes.

  Useful for fraud management, this lets you preview the side-effects of canceling a set of referrals, rewards, user events or any other graph node.
  
   - Is paginated
   - Can be filtered
  """
  moderateGraphNodes(
    graphNodeType: GraphNodeType!
    # Can be RewardFilterInput, ProgramEmailTransactionFilterInput,
    # ReferralFilterInput, or UserEventDataFilterInput depending on the type
    filter: RSJsonNode!
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
    moderationInput: ModerationInput!
  ): GraphNodeModerationResultList!
  """
  Lookup webhook history

  Useful for auditing webhook delivery failures
  
  Note that we only keep track of webhooks for 30 days.
  """
  webhooks(
    filter: WebhookFilterInput
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
  ): WebhookList!
  """
  Lists all the URLs that are currently subscribed to receive events via webhooks

  Useful for managing integrations and their connections. Note that integrations can also use managed webhooks to ensure the webhook exists as long as the integration is enabled.
  """
  webhookSubscriptions(
    limit: Int! = 20
    offset: Int! = 0
  ): WebhookSubscriptionList!

  """
  Lookup one RewardUnitSettings by id

  Useful for seeing details about a type of reward in use.
  """
  rewardUnitSettings(id: RewardUnitSettingsId!): RewardUnitSettings
  """
  List all Reward Unit settings

  Useful for seeing which reward units are in use, details about them, and to show that in the user interface.
  """
  rewardUnitSettingsList(
    limit: Int! = 20
    offset: Int! = 0
  ): RewardUnitSettingsList!

  """
  Details about the subject currently accessing the API.

  See the \`Viewer\` type for more details.
  """
  viewer: Viewer
}

type Mutation {
  # Creates a new program from a Program Template ID
  createProgram(id: ID, name: String!, programTemplateId: String!): Program!
  # Updates an existing program by id
  updateProgram(programInput: ProgramInput!): Program
  updateProgramId(id: ID!, newId: ID!): Program
  deleteProgram(id: String!): ProgramDeleteResult!
  createUser(userInput: UserInput!): User!
  upsertUser(userInput: UserInput!): User!
  upsertUsers(userInputs: [UserInput!]!): [UserUpsertResult!]!
  createCookieUser(userInput: UserInput!): User!
  # Doesn't actually return anything, graphql just doesn't have a Null datatype
  sendPreviewEmail(
    programId: String!
    emailKey: String!
    values: RSJsonNode
    toAddress: String!
    locale: String
  ): Boolean! # be less strict about locale
  updateTenant(tenantInput: TenantInput!): Tenant!
  updateTenantSettings(
    tenantSettingsInput: TenantSettingsInput!
  ): TenantSettings!
  testProgramSchedule(epochMilli: Long): [RSJsonNode!]!
  # Bulk custom code uploading for fueltank rewards
  addCustomCodes(data: CustomCodesInput!): CustomCodeInsertResult!
  upsertCustomCodes(data: CustomCodesInput!): CustomCodeUpsertResult!
  deleteCustomCodes(
    data: CustomCodesInput!
    createdBefore: RSDate
  ): CustomCodeDeleteResult!
  upsertTranslationInstance(
    translationInstanceInput: TranslationInstanceInput!
  ): TranslationInstance!
  deleteTranslationInstance(
    id: TranslationInstanceId!
  ): TranslationInstanceDeleteResult!
  createJob(jobInput: JobInput!): Job!
  deleteJob(id: ID!): JobDeleteResult!
  upsertSegment(segmentInput: SegmentInput!): Segment!
  upsertUserMetric(userMetricInput: UserMetricInput!): UserMetric!
  deleteUserMetric(customFieldKey: String!): UserMetricDeleteResult!
  logUserEvent(userEventInput: UserEventInput!): UserEventResult!
  blockUser(accountId: String!, id: String!): UserBlockingResult!
  unblockUser(accountId: String!, id: String!): UserBlockingResult!
  deleteUser(
    accountId: String!
    id: String!
    doNotTrack: Boolean! = false
  ): Boolean!
  deleteAccount(accountId: String!, doNotTrack: Boolean! = false): Boolean!
  deleteUserDoNotTrackIdentifier(
    id: String!
    accountId: String!
  ): UserDoNotTrackIdentifierDeleteResult!
  createReward(
    # https://docs.referralsaasquatch.com/api/methods/#create_reward
    rewardInput: RSJsonNode!
    userId: String!
    accountId: String!
    status: RewardStatus = AVAILABLE
  ): FlatReward!
  updateRewardStatus(id: ID!, status: RewardStatus!): FlatReward!
  updateProgramEmailTransactionStatus(
    id: ID!
    status: EmailTransactionStatus!
  ): ProgramEmailTransaction!
  deleteProgramEmailTransaction(id: ID!): ProgramEmailTransactionDeleteResult!
  createUserAnalyticsEvent(eventMeta: UserAnalyticsEvent!): Boolean!
  moderateGraphNodes(
    graphNodeType: GraphNodeType!
    # Can be RewardFilterInput, ProgramEmailTransactionFilterInput,
    # ReferralFilterInput, or UserEventDataFilterInput depending on the type
    filter: RSJsonNode!
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
    moderationInput: ModerationInput!
  ): GraphNodeModerationResultList!
  updatePortalProject(portalProjectInput: PortalProjectInput!): PortalProject!
  # Create or update a tenant integration
  upsertIntegration(
    integrationInput: TenantIntegrationInput!
  ): TenantIntegration
  deleteIntegration(service: String!): TenantIntegrationDeleteResult!
  # Patch the config of a TenantIntegration
  patchIntegrationConfig(
    service: String!
    # JSON Patch format (http://jsonpatch.com/)
    configPatch: RSJsonNode!
  ): TenantIntegration!
  # Subscribes a URL to receive events via webhooks
  upsertWebhookSubscription(
    webhookSubscriptionInput: WebhookSubscriptionInput!
  ): WebhookSubscription!
  # Removes a URL from receiving events via webhooks
  deleteWebhookSubscription(
    endpointUrl: String!
  ): WebhookSubscriptionDeleteResult!
  # Sends a test event to the specified webhook
  testWebhookSubscription(endpointUrl: String!): TestWebhookSubscriptionResult!
  # Upsert external metadata for a reward
  upsertRewardMeta(rewardMetaInput: RewardMetaInput!): FlatReward!
  # Upsert a RewardUnitSettings
  upsertRewardUnitSettings(
    rewardUnitSettingsInput: RewardUnitSettingsInput!
  ): RewardUnitSettings!
  # Delete a RewardUnitSettings
  deleteRewardUnitSettings(
    id: RewardUnitSettingsId!
  ): RewardUnitSettingsDeleteResult!
  # Clear the current tenant data if it's a test tenant
  deleteTestTenantData: Boolean!
}

input RewardMetaInput {
  rewardId: ID!
  status: RewardMetaStatus!
  message: String!
  integrationService: String
  customMeta: RSJsonNode
}

enum RSSortOrder {
  ASC
  DESC
}

input RSSortByInput {
  field: String!
  order: RSSortOrder!
}

type ZonedDateTime {
  offset: String!
  zone: String!
  year: Int!
  monthValue: Int!
  month: Month!
  dayOfMonth: Int!
  dayOfYear: Int!
  dayOfWeek: DayOfWeek!
  hour: Int!
  minute: Int!
  second: Int!
  nano: Int!
  epochMilli: RSDate!
}

enum Month {
  JANUARY
  FEBRUARY
  MARCH
  APRIL
  MAY
  JUNE
  JULY
  AUGUST
  SEPTEMBER
  OCTOBER
  NOVEMBER
  DECEMBER
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

# Static information about currencies. See: https://www.geoips.com/en/resources/currencies
type RSCurrency {
  # 3-letter ISO standard currency code e.g. "USD" or "GBP"
  currencyCode: RSCurrencyCode!
  # Human-readable currency name e.g. "US Dollars" or "Euro"
  displayName(locale: RSLocale): String!
  # The symbol of this currency for the specified locale.
  # For example, for the US Dollar, the symbol is "$" if the specified locale is the US,
  # while for other locales it may be "US$".
  # If no symbol can be determined, the ISO 4217 currency code is returned.
  symbol(locale: RSLocale): String!
  # The symbol for the default locale of this currency.
  # Note that the result may be incorrect for non-circulating currencies.
  localizedSymbol: String!
  # The ISO 4217 numeric code of this currency.
  numericCode: Int!
  # The default number of fraction digits used with this currency.
  # For example, the default number of fraction digits for the Euro is 2,
  # while for Libyan Dinar it's 3.
  fractionDigits: Int!
  # Human-readable non-plural name of the factional unit. e.g. "Cent" See: https://www.geoips.com/en/resources/currencies
  fractionalUnit: String
  # An integer representing the fractional unit to basic unit conversion. Usually 100.
  numberToBasic: Int!
  format(
    number: Float!
    locale: RSLocale
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
  formatFractionalUnit(
    number: Float!
    locale: RSLocale
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
}

type RSCurrencyList {
  data: [RSCurrency!]!
  count: Int!
  totalCount: Long!
}

type RewardUnit {
  key: String!
  name: String!
  currency: RSCurrency
}

# Settings for a reward unit
type RewardUnitSettings {
  id: RewardUnitSettingsId!
  config: RSJsonNode!
}

# A list of RewardUnitSettings
type RewardUnitSettingsList {
  data: [RewardUnitSettings!]!
  count: Int!
  totalCount: Long!
}

type RewardUnitSettingsDeleteResult {
  deletedCount: Long!
}

input RewardUnitSettingsInput {
  id: RewardUnitSettingsId!
  config: RSJsonNode!
}

interface Viewer {
  permissions: [String!]!
}

interface GraphNodeData {
  id: ID!
  moderationPreview(
    moderationInput: ModerationInput!
  ): GraphNodeModerationPreviewList!
}

enum GraphNodeType {
  REWARD
  PROGRAM_EMAIL
  REFERRAL
  USER_EVENT
}

type GraphNode {
  data: GraphNodeData
  parent: GraphNodeData
  depth: Int!
}

input ModerationInput {
  # The moderation action, can be "APPROVE" or "DENY"
  action: String!
  # The max depth of side effects
  maxDepth: Int!
  # graph lookup size limit.
  # Default to 20 for query, and 1000 for moderation.
  limit: Int
  # graph lookup offset.
  # Default to 0.
  offset: Int
  # Graph nodes must meet this condition to be moderated.
  # Graph nodes that don't meet this condition will still show up in the result,
  # but the action will be NOTHING.
  actionPredicate: ModerationActionPredicateInput
}

input ModerationActionPredicateInput {
  programId_eq: ID
}

type ModerationInputView {
  action: String!
  maxDepth: Int!
  limit: Int
  offset: Int
}

type GraphNodeList {
  data: [GraphNode!]!
  count: Int!
  totalCount: Long!
}

type GraphNodeModerationPreview {
  data: GraphNodeData
  parent: GraphNodeData
  depth: Int
  action: String
  description: String
}

type GraphNodeModerationPreviewList {
  data: [GraphNodeModerationPreview!]!
  count: Int!
  totalCount: Long!
}

type GraphNodeModerationResult {
  data: GraphNodeData
  moderationResults: GraphNodeModerationPreviewList
}

type GraphNodeModerationResultList {
  data: [GraphNodeModerationResult!]!
  count: Int!
  # totalCount is null for USER_EVENT
  totalCount: Long
}

interface ProgramTrigger {
  id: ID!
  type: ProgramTriggerType!
  time: RSDate!
  user: User
}

type AfterUserCreatedOrUpdatedTrigger implements ProgramTrigger {
  id: ID!
  type: ProgramTriggerType!
  time: RSDate!
  user: User
  previous: User
  events: [UserEventData!]!
}

type ScheduledProgramTrigger implements ProgramTrigger {
  id: ID!
  type: ProgramTriggerType!
  time: RSDate!
  user: User
  scheduleKey: String
}

type RewardScheduledProgramTrigger implements ProgramTrigger {
  id: ID!
  type: ProgramTriggerType!
  time: RSDate!
  user: User
  reward: FlatReward
  scheduleKey: String
}

type ReferralProgramTrigger implements ProgramTrigger {
  id: ID!
  type: ProgramTriggerType!
  time: RSDate!
  user: User
  referral: Referral!
  referralEventType: ReferralEventType!
}

type AfterUserEventProcessedTrigger implements ProgramTrigger {
  id: ID!
  type: ProgramTriggerType!
  time: RSDate!
  user: User
  events: [UserEventData!]!
}

enum ProgramTriggerType {
  AFTER_USER_CREATED_OR_UPDATED
  SCHEDULED
  REWARD_SCHEDULED
  REFERRAL
  AFTER_USER_EVENT_PROCESSED
}

enum ReferralEventType {
  STARTED
  MODERATION_ACTION_APPLIED
  AUTOMODERATION_COMPLETE
}

enum GAProgramType {
  ACQUISITION
  LOYALTY
  RETENTION
}

type ProgramTransaction {
  id: ID!
  mutations: [ProgramMutation!]
  analytics: [ProgramAnalyticsData!]
  program: Program
}

union ProgramMutation =
    ProgramCreateRewardMutation
  | ProgramSendEmailMutation
  | ProgramModerateGraphNodesMutation

type ProgramCreateRewardMutation {
  key: String
  rewardConfig: ProgramRewardConfig
  template: ProgramRewardTemplate
  user: User
  rewardSource: RewardSourceType
}

type ProgramSendEmailMutation {
  key: String
  emailConfig: ProgramEmailConfig
  template: ProgramEmailTemplate
  user: User
  status: EmailTransactionStatus
}

type ProgramModerateGraphNodesMutation {
  graphNodeType: GraphNodeType
  moderationInput: ModerationInputView
  moderationPreview: GraphNodeModerationResultList
}

union ProgramAnalyticsData =
    ProgramEvaluatedAnalyticsData
  | ProgramGoalAnalyticsData

type ProgramEvaluatedAnalyticsData {
  user: User
  timestamp: RSDate
  analyticsKey: String
  analyticsDedupeId: String
  programType: GAProgramType
}

type ProgramGoalAnalyticsData {
  user: User
  timestamp: RSDate
  analyticsKey: String
  analyticsDedupeId: String
  programType: GAProgramType
}

union UserUpsertResult = User | ApiError

type ApiError {
  message: String!
  statusCode: Int!
  rsCode: String
}

type User implements Viewer {
  id: String!
  accountId: String!
  firstName: String
  lastName: String
  lastInitial: String
  referralCode(programId: ID): String
  referralCodes: RSShallowMap!
  imageUrl: String
  email: String
  cookieId: String
  paymentProviderId: String
  locale: RSLocale
  referable: Boolean
  # key value pair
  customFields: RSJsonNode
  firstSeenIP: String
  lastSeenIP: String
  firstSeenIPLocation: LatLon
  lastSeenIPLocation: LatLon
  # Maxmind geo data
  firstSeenGeoData: RSJsonNode
  # Maxmind geo data
  lastSeenGeoData: RSJsonNode
  firstSeenUserAgent: String
  lastSeenUserAgent: String
  dateCreated: RSDate
  dateBlocked: RSDate
  emailHash: String
  referralSource: String @deprecated
  # Legacy share links format.
  # https://docs.referralsaasquatch.com/api/methods/#get_sharelinks
  incompleteShareLinks: RSJsonNode
    @deprecated(reason: "Use shareLinks instead.")
  # https://docs.referralsaasquatch.com/api/methods/#get_shareurls
  shareLinks(
    programId: ID
    shareMedium: ReferralShareMedium
    engagementMedium: UserEngagementMedium
  ): RSJsonNode
  shareLink(
    programId: ID
    shareMedium: ReferralShareMedium! = UNKNOWN
    engagementMedium: UserEngagementMedium! = UNKNOWN
  ): String
  messageLink(
    programId: ID
    shareMedium: ReferralShareMedium! = UNKNOWN
    engagementMedium: UserEngagementMedium! = UNKNOWN
  ): String
  shareLinkOpenGraph(programId: ID): RSJsonNode
  messageLinkOpenGraph(programId: ID): RSJsonNode
  referredBy: UserReferredByInfo
    @deprecated(reason: "Use referredByReferral instead.")
  referredByReferral(programId: ID): Referral
  referredByReferrals: [Referral!]!
  referredByCodes: [String!]!
  rewards(
    filter: RewardFilterInput
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
  ): FlatRewardList!
  # https://docs.referralsaasquatch.com/api/methods/#list_balances
  rewardBalances(
    rewardType: RewardType
    programId: ID
    locale: RSLocale
  ): RSJsonNode @deprecated(reason: "Use rewardBalanceDetails instead")
  rewardBalanceDetails(
    filter: RewardBalanceFilterInput
    programId: ID
    locale: RSLocale
  ): [RewardBalance!]!
  referrals(
    filter: ReferralFilterInput
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
  ): ReferralList!
  widget(
    widgetType: WidgetType
    engagementMedium: UserEngagementMedium
  ): WidgetResponse
  segments: [SegmentKey!]!
  fraudFlags: [FraudFlag!]!
  stats: UserStats
  userEvents(
    # Only dateTriggered field can be filtered for purchase and refund events.
    # Nothing can be filtered for other events.
    filter: UserEventDataFilterInput
    # Deprecated. Use filter.key instead.
    eventKey: String
    limit: Int! = 20
    offset: Int! = 0
    sortBy: [RSSortByInput!]
  ): UserEventDataList!
  programEmailTransactions(
    filter: ProgramEmailTransactionFilterInput
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
    sortBy: [RSSortByInput!]
  ): ProgramEmailTransactionList!
  permissions: [String!]!
}

type UserStats {
  dateModified: RSDate
  traffic: Int
  referrals: Int
  conversions: Int
  goals: Int
  rewards: Int
  revenue: Float
  generatedRevenue: Float
  referredRevenue: Float
}

type PaymentAccount {
  id: String!
  dateCreated: RSDate
  dateModified: RSDate
  users(limit: Int! = 20, offset: Int! = 0): UserList!
}

type WidgetResponse {
  template: String!
  jsOptions: RSJsonNode
  user: User
}

type LatLon {
  lat: Float!
  lon: Float!
}

enum ReferralShareMedium {
  FACEBOOK
  TWITTER
  EMAIL
  DIRECT
  LINKEDIN
  SMS
  FBMESSENGER
  WHATSAPP
  LINEMESSENGER
  PINTEREST
  REMINDER
  UNKNOWN
}

enum UserEngagementMedium {
  NOCONTENT
  EMBED
  HOSTED
  MOBILE
  POPUP
  DEMO_EMBED
  DEMO
  EMPTY
  EMAIL
  UNKNOWN
}

type FlatRewardList {
  data: [FlatReward!]!
  count: Int!
  totalCount: Long!
}

type UserReferredByInfo {
  isConverted: Boolean
  code: String
  newlyReferred: Boolean
  referredReward: RSJsonNode
}

type UserList {
  data: [User]!
  count: Int!
  totalCount: Long!
}

input RewardFilterInput {
  AND: [RewardFilterInput!]
  OR: [RewardFilterInput!]
  id_eq: ID
  id_in: [ID!]
  type_eq: RewardType
  type_in: [RewardType!]
  # only applies to credit rewards
  unit_eq: String
  # only applies to credit rewards
  unit_in: [String!]
  dateCreated_gte: RSDate
  dateCreated_lt: RSDate
  dateCreated_timeframe: RSRelativeTimeframe
  dateGiven_gte: RSDate
  dateGiven_lt: RSDate
  dateGiven_timeframe: RSRelativeTimeframe
  dateGiven_exists: Boolean
  dateExpires_gte: RSDate
  dateExpires_lt: RSDate
  dateExpires_timeframe: RSRelativeTimeframe
  dateExpires_exists: Boolean
  dateCancelled_gte: RSDate
  dateCancelled_lt: RSDate
  dateCancelled_timeframe: RSRelativeTimeframe
  dateCancelled_exists: Boolean
  rewardSource_eq: RewardSourceType
  rewardSource_in: [RewardSourceType!]
  userId_eq: String
  accountId_eq: String
  programId_eq: ID
  programId_in: [ID!]
  programId_exists: Boolean
  programRewardKey_eq: String
  programRewardKey_in: [String!]
  programRewardKey_exists: Boolean
}

input RewardBalanceFilterInput {
  type_eq: RewardType
  unit_eq: String
  unit_in: [String!]
  unitType_eq: String
  currency_eq: RSCurrencyCode
}

type FlatReward implements GraphNodeData {
  id: ID!
  # The type of reward
  type: RewardType!
  # The value of the reward
  value: Int!
  # A human-readable formatted string value based on the reward's unit
  prettyValue(
    locale: RSLocale
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
  availableValue: Int!
  prettyAvailableValue(
    locale: RSLocale
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
  # The unit represented by the value of this reward
  unit: String!
  rewardUnit: RewardUnit!
  # The displayable name for the reward
  name: String
  # The date the reward was created
  dateCreated: RSDate
  # The date the reward is scheduled to be given
  dateScheduledFor: RSDate
  # The date the reward was given
  dateGiven: RSDate
  # The date the reward expires (null if it doesn't expire)
  dateExpires: RSDate
  # The date the reward was cancelled
  dateCancelled: RSDate
  # The source of the reward (i.e. by friend referral, manual, etc)
  rewardSource: RewardSourceType
  # The fuel tank code associated with the reward if this is fuel tank reward
  fuelTankCode: String
  # The fuel tank type associated with the reward if this is a fuel tank reward
  fuelTankType: FuelTankType
  # The currency the reward was associated with if applicable (gift cards are associated with a currency)
  currency: RSCurrencyCode
  cancellable: Boolean!
  redeemable: Boolean!
  # External metadata set by integrations or third-parties
  meta: RewardMeta
  # The id of the program that created this reward
  programId: String
  # The corresponding reward key in the program that created this rewards
  programRewardKey: String
  # The program that created this reward
  program: Program
  # The user this reward belongs to
  user: User!
  integrationId: ID
  integration: TenantIntegration
  description: String
  assignedCredit: Int
  redeemedCredit: Int
  prettyAssignedCredit(
    locale: RSLocale
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String
  prettyRedeemedCredit(
    locale: RSLocale
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String
  referralId: ID
  referral: Referral
  statuses: [RewardStatus!]!
  moderationPreview(
    moderationInput: ModerationInput!
  ): GraphNodeModerationPreviewList!
}

# External metadata for a reward intended to be used by external integrations
type RewardMeta {
  status: RewardMetaStatus!
  message: String!
  integration: TenantIntegration
  dateModified: RSDate
  customMeta: RSJsonNode
}

enum RewardMetaStatus {
  SUCCESS
  WARN
  ERROR
}

enum RewardValueFormatType {
  # Formatted number only
  NUMBER_FORMATTED
  # Formatted integer only with rounding
  INTEGER_FORMATTED
  # Full currency format with number and currency code
  UNIT_FORMATTED
  NUMBER_UNFORMATTED
  INTEGER_UNFORMATTED
}

interface RewardBalance {
  type: RewardType!
  unit: String!
  rewardUnit: RewardUnit!
  availableValue: Int!
  prettyAvailableValue(
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
}

type CreditRewardBalance implements RewardBalance {
  type: RewardType!
  unit: String!
  rewardUnit: RewardUnit!
  availableValue: Int!
  prettyAvailableValue(
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
  count: Int!
  totalPendingCredit: Int!
  totalAssignedCredit: Int!
  totalRedeemedCredit: Int!
  totalExpiredCredit: Int!
  totalCancelledCredit: Int!
  prettyPendingCredit(
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
  prettyAssignedCredit(
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
  prettyRedeemedCredit(
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
  prettyExpiredCredit(
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
  prettyCancelledCredit(
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
}

type DiscountPercentRewardBalance implements RewardBalance {
  type: RewardType!
  unit: String!
  rewardUnit: RewardUnit!
  availableValue: Int!
  prettyAvailableValue(
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
  totalDiscountPercent: Int!
  referredDiscountPercent: Int!
  referrerDiscountPercent: Int!
}

type FuelTankRewardBalance implements RewardBalance {
  type: RewardType!
  unit: String!
  rewardUnit: RewardUnit!
  availableValue: Int!
  prettyAvailableValue(
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
  totalFuelTankCodes: Int!
}

type IntegrationRewardBalance implements RewardBalance {
  type: RewardType!
  unit: String!
  rewardUnit: RewardUnit!
  availableValue: Int!
  prettyAvailableValue(
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
  # Shallow map of string to integer
  unitBalances: RSShallowMap!
}

enum RewardStatus {
  PENDING
  CANCELLED
  EXPIRED
  REDEEMED
  AVAILABLE
}

enum RewardType {
  PCT_DISCOUNT
  CREDIT
  FUELTANK
  INTEGRATION
}

enum RewardSourceType {
  # This source type designates a reward that was given to a user (A) for their friend (B)
  # signing up.
  FRIEND_SIGNUP
  # This source type designates a reward that was given to a user for signing up by referral
  REFERRED
  # This source type designates a reward that was manually added to a user via portal or API
  MANUAL
  PROGRAM @deprecated(reason: "use AUTOMATED instead")
  ACTIVATION
  ACQUISITION
  RETENTION
  REACTIVATION
  # Reward given by a program
  AUTOMATED
}

enum FuelTankType {
  PCT_DISCOUNT
  CREDIT
}

type Referral implements GraphNodeData {
  # Id of this referral
  id: ID!
  # Id of the corresponding program (non-legacy referrals)
  programId: ID
  program: Program
  # public meta available on this referral
  publicMeta: RSJsonNode @deprecated
  # private meta available on this referral
  privateMeta: RSJsonNode @deprecated
  referredUser: User
  referrerUser: User
  # The reward earned for this referral by the referred user
  referredReward: FlatReward @deprecated(reason: "Use rewards instead.")
  # The reward earned for this referral by the referrer
  referrerReward: FlatReward @deprecated(reason: "Use rewards instead.")
  # The overall moderation status for the referral
  moderationStatus: ReferralModerationStatus
  # The moderation status of the referred user
  referredModerationStatus: ReferralSideModerationStatus
  # The moderation status of the referrer user
  referrerModerationStatus: ReferralSideModerationStatus
  # The date the referral was made
  dateReferralStarted: RSDate
  # The date the referral converted to paid
  dateReferralPaid: RSDate
  # The date the referred user stopped payment
  dateReferralEnded: RSDate
  # The last date the referral was moderated
  dateModerated: RSDate
  dateUserModified: RSDate
  dateFraudChecksCompleted: RSDate @deprecated(reason: "Internal field.")
  dateConverted: RSDate
  dateModified: RSDate
  fraudSignals: RSJsonNode @deprecated(reason: "Use fraudFlags instead.")
  fraudFlags: [FraudFlag!]!
  # True if this referral is exempt from fraud moderation
  isFraudExempt: Boolean!
  rewards(filter: RewardFilterInput): [FlatReward!]!
  childNodes(
    maxDepth: Int! = 5
    # graph lookup size limit
    limit: Int! = 20
    # graph lookup offset
    offset: Int! = 0
  ): GraphNodeList!
  moderationPreview(
    moderationInput: ModerationInput!
  ): GraphNodeModerationPreviewList!
}

type ReferralList {
  data: [Referral!]!
  count: Int!
  totalCount: Long!
}

type FraudFlag {
  type: FraudType!
  message: String!
}

enum FraudType {
  IP
  EMAIL
  NAME
  RATE
  DAILY_REFERRAL_REWARD_LIMIT
  TEMP_EMAIL
  BLOCKED_USER
  BLOCKED_IP
}

enum ReferralModerationStatus {
  PENDING
  ACTIONED
}

enum ReferralSideModerationStatus {
  PENDING
  APPROVED
  DENIED
}

type PortalUser implements Viewer {
  identity: ID!
  email: String
  tenants: [Tenant!]!
  permissions: [String!]!
}

type Tenant implements Viewer {
  tenantAlias: ID!
  isLiveMode: Boolean!
  emailAddress: String
  dateCreated: RSDate
  rateLimitMultiplier: Float
  settings: TenantSettings
  theme: TenantTheme
  clockOffsetMillis: Long
  clockOffsetDuration: IsoDuration
  permissions: [String!]!
}

input ReferralFilterInput {
  AND: [ReferralFilterInput!]
  OR: [ReferralFilterInput!]
  id_eq: ID
  id_in: [ID!]
  programId_eq: ID
  programId_in: [ID!]
  programId_exists: Boolean
  dateReferralStarted_gte: RSDate
  dateReferralStarted_lt: RSDate
  dateReferralStarted_timeframe: RSRelativeTimeframe
  dateReferralPaid_gte: RSDate
  dateReferralPaid_lt: RSDate
  dateReferralPaid_timeframe: RSRelativeTimeframe
  dateReferralPaid_exists: Boolean
  dateReferralEnded_gte: RSDate
  dateReferralEnded_lt: RSDate
  dateReferralEnded_timeframe: RSRelativeTimeframe
  dateReferralEnded_exists: Boolean
  dateConverted_gte: RSDate
  dateConverted_lt: RSDate
  dateConverted_timeframe: RSRelativeTimeframe
  dateConverted_exists: Boolean
  dateModerated_gte: RSDate
  dateModerated_lt: RSDate
  dateModerated_timeframe: RSRelativeTimeframe
  dateModerated_exists: Boolean
  dateModified_gte: RSDate
  dateModified_lt: RSDate
  dateModified_timeframe: RSRelativeTimeframe
  referredModerationStatus_eq: ReferralSideModerationStatus
  referredModerationStatus_in: [ReferralSideModerationStatus!]
  referrerModerationStatus_eq: ReferralSideModerationStatus
  referrerModerationStatus_in: [ReferralSideModerationStatus!]
  moderationStatus_eq: ReferralModerationStatus
  moderationStatus_in: [ReferralModerationStatus!]
}

type TenantSettings {
  signupPage: String
  companyName: String
  hasUtmOnSignupPage: Boolean
  customShortDomain: String
  referredAutoApprove: Boolean
  referrerAutoApprove: Boolean
  suspectedFraudModerationState: SuspectedFraudModerationState
  potentialFraudNotificationFrequency: String
  fraudCheckSettings: FraudCheckSettings
  fraudRateLimit: Int
  fraudRateLimitPeriodSeconds: Int
  dailyReferralRewardLimit: Int
  rewardSettings: RSJsonNode
  allowReferralInvites: Boolean
  multiProgramEnabled: Boolean
}

enum SuspectedFraudModerationState {
  DENY
  PENDING
  IGNORE
}

type FraudCheckSettings {
  ipCheckEnabled: Boolean
  nameCheckEnabled: Boolean
  emailCheckEnabled: Boolean
  rateCheckEnabled: Boolean
  tempMailCheckEnabled: Boolean
  customEmailDomainBlacklist: [String!]
  dailyReferralRewardLimitEnabled: Boolean
}

type TenantTheme implements TranslatableAsset {
  id: ID!
  variables(locale: String): RSJsonNode # be less strict about locale
  variablesSchema: RSJsonNode
  themeConfig: ThemeConfig
  translationInfo: TranslationInfo!
}

type ThemeConfig {
  vcs: GitConfig
  themeAssetVersion: String
  templateFileNames: [String!]
}

type GitConfig {
  repositoryUrl: String
  branch: String
  username: String
  password: String
}

type UserBlockingResult {
  user: User
}

input TenantInput {
  clockOffsetMillis: Long
  clockOffsetDuration: IsoDuration
}

input TenantSettingsInput {
  companyName: String
  multiProgramEnabled: Boolean
}

input UserInput {
  id: String
  accountId: String
  firstName: String
  lastName: String
  lastInitial: String
  referralCode: String
  referralCodes: RSShallowMap
  imageUrl: String
  email: String
  cookieId: String
  paymentProviderId: String
  locale: RSLocale
  # Deprecated. Use referredByCodes instead.
  referredBy: RSJsonNode
  """
  The Base64URL encoded attribution cookie values.

  When decoded, the schema will resemble the following:
  
  {"app.referralsaasquatch.com": {"tenantAlias_CODE": {"codes": {"program1": "CODE1"},"codesExp": {"CODE1": 1234567}}}}
  """
  referredByCodes: [String!]
  cookies: String
  referable: Boolean
  customFields: RSJsonNode
  segments: [SegmentOperation!]
}

# filter to find only relevant users to trigger a program with
input UserFilterInput {
  AND: [UserFilterInput!]
  OR: [UserFilterInput!]
  id_eq: String
  accountId_eq: String
  firstName_eq: String
  lastName_eq: String
  email_eq: String
  email_exists: Boolean
  locale_eq: RSLocale
  locale_in: [RSLocale!]
  firstSeenIP_eq: String
  lastSeenIP_eq: String
  dateBlocked_exists: Boolean
  customFields: RSJsonNode
  # contains
  segments_eq: String
  # does not contain
  segments_ne: String
  # contains any
  segments_in: [String!]
  # contains all
  segments_all: [String!]
  fraudFlags_exists: Boolean
  fraudFlags_all: [FraudType!]
}

type PersistedEvent {
  meta: RSJsonNode
  blob: RSJsonNode
}

type PersistedEventList {
  data: [PersistedEvent!]!
  count: Int!
  totalCount: Long!
}

# A program installed in a tenant based on a program template
type Program {
  id: ID!
  name: String!
  status: ProgramStatus!
  template: ProgramTemplate!
  rawTemplate: ProgramTemplate! @deprecated(reason: "Internal field.")
  emails: [ProgramEmailConfig!]
  email(key: String!): ProgramEmailConfig
  rewards: [ProgramRewardConfig!]
  reward(key: String!): ProgramRewardConfig
  widgets: [ProgramWidgetConfig!]
  widget(key: String!): ProgramWidgetConfig
  sharing: ProgramSharingConfig
  # An instance of the values in the Program Template's rules schema
  rules: RSJsonNode
  analytics: RSJsonNode
  dateCreated: RSDate!
  lastActivatedDate: RSDate
  taskState(key: String! = "default"): ProgramTaskState
  taskStates: [ProgramTaskState!]
  rewardsGiven(
    filter: RewardFilterInput
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
  ): FlatRewardList!
  referrals(
    filter: ReferralFilterInput
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
    sortBy: [RSSortByInput!]
  ): ReferralList
  transactionEvents(
    createdAfter: RSDate
    createdBefore: RSDate
    metaFilter: RSJsonNode
    limit: Int! = 20
    offset: Int! = 0
  ): PersistedEventList @deprecated
  translatableAssets: [TranslatableAsset!]!
  programEmailTransactions(
    filter: ProgramEmailTransactionFilterInput
    timeZone: String
    timeZoneOffset: Int
    limit: Int! = 20
    offset: Int! = 0
    sortBy: [RSSortByInput!]
  ): ProgramEmailTransactionList!
  validation(key: String!): ProgramValidationResult
  validations: [ProgramValidationResult!]
}

enum ProgramStatus {
  PAUSED
  LIVE
}

type ProgramList {
  data: [Program!]
  count: Int!
  totalCount: Long!
}

type ProgramDeleteResult {
  deletedCount: Long!
}

# A type of email sent by a program. e.g. "VIP Reward Limit Reached Email"
type ProgramEmailTemplate {
  key: String!
  name: String!
  description: String!
  defaults: RSJsonNode!
}

# Config values for an email type
type ProgramEmailConfig implements TranslatableAsset {
  key: String!
  enabled: Boolean!
  values: RSJsonNode!
  # be less strict about locale
  preview(values: RSJsonNode, locale: String): EmailPreview!
  translationInfo: TranslationInfo!
}

# Config values for a widget type
type ProgramWidgetConfig implements TranslatableAsset {
  key: String!
  values: RSJsonNode!
  widgetType: WidgetType!
  # preview goes here - see ProgramEmailConfig
  translationInfo: TranslationInfo!
}

type ProgramSharingConfig {
  redirectUrl: ProgramRedirectUrlConfig
  linkConfig: ProgramLinkConfig
}

type ProgramRedirectUrlConfig {
  url: String!
  fallbackUrl: String!
  """
  Expiry duration for referral code cookies
  """
  cookieExpiryDuration: IsoDuration!
  rules: RSJsonNode
}

type ProgramLinkConfig implements TranslatableAsset {
  messaging: ProgramMessagingConfig!
  translationInfo: TranslationInfo!
}

type ProgramMessagingConfig {
  messages: [ProgramMessageConfig!]
  messageLinkOpenGraph: ProgramOpenGraphMetaConfig
  shareLinkOpenGraph: ProgramOpenGraphMetaConfig
}

type ProgramMessageConfig {
  shareMedium: ReferralShareMedium!
  config: RSJsonNode
}

type ProgramOpenGraphMetaConfig {
  title: String
  description: String
  image: String
  source: ProgramOpenGraphSource
}

enum ProgramOpenGraphSource {
  HOSTED
  LANDING_PAGE
}

type EmailPreview {
  headers: RSJsonNode
  body: String
}

type ProgramTaskState {
  key: String!
  invocationNumber: Long!
  status: ScheduledTaskStatus!
}

enum ScheduledTaskStatus {
  RUNNING
  IDLE
}

type ProgramValidationResult {
  key: String!
  results: [ProgramRequirementValidationResult!]
  requirement: ProgramRequirement
}

type ProgramRequirementValidationResult {
  status: ProgramRequirementValidationStatus!
  message: String!
  longDescription: String
}

enum ProgramRequirementValidationStatus {
  SUCCESS
  WARN
  ERROR
}

type ProgramTemplate {
  # A unique global ID for this program
  id: String!
  # A human friendly name of the program
  name: String!
  summary: String!
  longDescription: String!
  installGuide: String
  # An external link to the docs refererence for this program's install guide
  installGuideUrl: String
  # A list of email types sent by this program template
  emails: [ProgramEmailTemplate!]
  # A list of named reward types
  rewards: [ProgramRewardTemplate!]
  # A list of widgets used by this program template
  widgets: [ProgramWidgetTemplate!]
  # A JSON schema describing how a program should be configured
  rules: RSJsonNode
  # A JSON UI schema describing how the rules form should look
  rulesUISchema: RSJsonNode
  # A webtask.io / Auth0 Extend URL to call to execute the code
  url: String
  # A url pointing to the program logo
  logo: String
  # Program attribution settings if the program supports attribution
  sharing: ProgramTemplateSharingSettings
  requirements: [ProgramRequirement!]
}

type ProgramTemplateSharingSettings {
  # Whether attribution is enabled or not
  enabled: Boolean!
}

type ProgramRewardTemplate {
  key: String
  name: String!
  description: String!
  isDynamic: Boolean!
}

type ProgramWidgetTemplate {
  key: String
  name: String!
  description: String!
  defaults: RSJsonNode!
}

type ProgramRewardConfig implements IsPredefinedReward & TranslatableAsset {
  key: String!
  name: String
  description: String
  rewardType: RewardType
  amount: Int
  unit: String
  currency: RSCurrencyCode
  monthsDiscountIsValid: Int
    @deprecated(reason: "Use validityDuration instead.")
  validityDuration: IsoDuration
  fuelTankType: FuelTankType
  # Unique global ID for predefined rewards
  predefinedRewardType: PredefinedRewardType!
  # The custom codes used for FUELTANK rewards
  customCodes(
    used: Boolean! = false
    limit: Int! = 20
    offset: Int! = 0
  ): CustomCodeList
  integrationId: ID
  integration: TenantIntegration
  # Integration specific configuration (i.e. external gift card identifiers)
  # TODO - include externalRewardId and integrationTemplateId in integrationSettings
  integrationSettings: RSJsonNode
  translationInfo: TranslationInfo!
  prettyValue(
    locale: RSLocale
    formatType: RewardValueFormatType! = UNIT_FORMATTED
  ): String!
}

type ProgramRequirement {
  key: String!
  name: String
  description: String
  longDescription: String
  query: String @deprecated(reason: "Internal field.")
  queryVariables: RSJsonNode @deprecated(reason: "Internal field.")
}

type ProgramEmailTransaction implements GraphNodeData {
  id: ID!
  programId: ID
  # Program that generated the email
  program: Program
  # Program email key
  key: String!
  # User receiving the email
  user: User!
  # Program generated context query for email rendering
  query: String!
  queryVariables: RSJsonNode!
  # Date the transaction was created
  dateCreated: RSDate!
  # Date the transaction was queued
  dateQueued: RSDate
  # Date the email was sent
  dateSent: RSDate
  status: EmailTransactionStatus!
  rewardId: ID
  reward: FlatReward
  moderationPreview(
    moderationInput: ModerationInput!
  ): GraphNodeModerationPreviewList!
}

enum EmailTransactionStatus {
  PENDING
  QUEUED
  SENT
  FAILED
}

type ProgramEmailTransactionList {
  data: [ProgramEmailTransaction!]!
  count: Int!
  totalCount: Long!
}

type ProgramEmailTransactionDeleteResult {
  deletedCount: Long!
}

input ProgramEmailTransactionFilterInput {
  AND: [ProgramEmailTransactionFilterInput!]
  OR: [ProgramEmailTransactionFilterInput!]
  id_eq: ID
  id_in: [ID!]
  programId_eq: ID
  key_eq: String
  key_in: [String!]
  dateCreated_gte: RSDate
  dateCreated_lt: RSDate
  dateCreated_timeframe: RSRelativeTimeframe
  dateQueued_gte: RSDate
  dateQueued_lt: RSDate
  dateQueued_timeframe: RSRelativeTimeframe
  dateSent_gte: RSDate
  dateSent_lt: RSDate
  dateSent_timeframe: RSRelativeTimeframe
  status_eq: EmailTransactionStatus
  status_in: [EmailTransactionStatus!]
}

type TenantIntegration {
  id: ID! @deprecated(reason: "use service instead")
  service: String!
  name: String!
  type: IntegrationType
  enabled: Boolean!
  config: RSJsonNode
}

enum IntegrationType {
  LINK_GENERATOR
  EMAIL_DELIVERY
  REWARD_PROVIDER
}

type TenantIntegrationList {
  data: [TenantIntegration!]!
  count: Int!
  totalCount: Long!
}

type TenantIntegrationDeleteResult {
  deletedCount: Long!
}

input TenantIntegrationInput {
  service: String!
  enabled: Boolean
  config: RSJsonNode
}

# A webhook with its payload
type Webhook {
  id: ID!
  type: String!
  dateCreated: RSDate!
  data: RSJsonNode
  # Get the delivery attempt logs for this webhook
  subscriptionLog(
    limit: Int! = 20
    offset: Int! = 0
  ): WebhookSubscriptionLogList!
}

# Delivery attempt logs for one WebhookSubscription
type WebhookSubscriptionLog {
  # The url of the endpoint that receives events
  endpointUrl: String!
  subscription: WebhookSubscription
  # The list of HTTP request attempts to this webhook subscription
  attempts(limit: Int! = 20, offset: Int! = 0): WebhookDeliveryAttemptList!
}

# A list of WebhookSubscriptionLogs
type WebhookSubscriptionLogList {
  data: [WebhookSubscriptionLog!]!
  count: Int!
  totalCount: Long!
}

# The result of one HTTP request attempt to a webhook subscription
type WebhookDeliveryAttempt {
  dateAttempted: RSDate
  # The status received from the endpoint. Null if we weren't able to connect.
  status: Int
}

# A list of WebhookDeliveryAttempts
type WebhookDeliveryAttemptList {
  data: [WebhookDeliveryAttempt!]!
  count: Int!
  totalCount: Long!
}

# A list of Webhooks
type WebhookList {
  data: [Webhook!]!
  count: Int!
  totalCount: Long!
}

# A webhook subscription to an endpoint
type WebhookSubscription {
  # The url of the endpoint that receives events
  endpointUrl: String!
  # Display name
  name: String
  source: WebhookSubscriptionSourceType!
  integration: TenantIntegration
}

# The source that created a WebhookSubscription
enum WebhookSubscriptionSourceType {
  # Created through the portal or API
  MANUAL
  # Managed by an integration
  INTEGRATION
}

# A list of WebhookSubscriptions
type WebhookSubscriptionList {
  data: [WebhookSubscription!]!
  count: Int!
  totalCount: Long!
}

type WebhookSubscriptionDeleteResult {
  deletedCount: Long!
}

input WebhookSubscriptionInput {
  # The url of the endpoint that receives events
  endpointUrl: String!
  # Optional name of the endpoint that receives events
  name: String
}

input WebhookFilterInput {
  AND: [WebhookFilterInput!]
  OR: [WebhookFilterInput!]
  id_eq: ID
  type_eq: String
  dateCreated_gte: RSDate
  dateCreated_lt: RSDate
  dateCreated_timeframe: RSRelativeTimeframe
}

type TestWebhookSubscriptionResult {
  subscription: WebhookSubscription!
}

# Codes used for FUELTANK rewards
type CustomCode {
  code: String!
  dateUploaded: RSDate
  # The date when a custom code was allocated to someone,
  # not necessarily when it was redeemed.
  dateUsed: RSDate
  predefinedRewardType: PredefinedRewardType!
  reward: FlatReward
}

type CustomCodeList {
  data: [CustomCode!]!
  count: Int!
  totalCount: Long!
}

input CustomCodesInput {
  # See IsPredefinedReward
  predefinedRewardType: PredefinedRewardType!
  codes: [String!]!
}

type RejectedCustomCode {
  code: String
  rejectReason: String
}

type CustomCodeInsertResult {
  rejectedCodes: [RejectedCustomCode!]!
  numCodesRejected: Int!
  numCodesAccepted: Int!
}

type CustomCodeUpsertResult {
  rejectedCodes: [RejectedCustomCode!]!
  numCodesRejected: Int!
  numCodesInserted: Int!
  numCodesUpdated: Int!
}

type CustomCodeDeleteResult {
  deletedCount: Long!
}

# Interface type for either a ProgramRewardConfig or a legacy RewardSetting
interface IsPredefinedReward {
  predefinedRewardType: PredefinedRewardType!
}

input ProgramFilterInput {
  AND: [ProgramFilterInput!]
  OR: [ProgramFilterInput!]
  id_eq: ID
  id_in: [ID!]
  name_eq: String
  name_in: [String!]
  status_eq: ProgramStatus
  dateCreated_gte: RSDate
  dateCreated_lt: RSDate
  dateCreated_timeframe: RSRelativeTimeframe
  referralsEnabled: Boolean
}

input ProgramInput {
  id: ID!
  name: String
  status: ProgramStatus
  emails: [ProgramEmailConfigInput!]
  rewards: [ProgramRewardConfigInput!]
  widgets: [ProgramWidgetConfigInput!]
  sharing: ProgramSharingConfigInput
  # An instance of the values in the Program Template's rules schema
  rules: RSJsonNode
  analytics: RSJsonNode
  # Deprecated. Use taskStates instead.
  taskState: ProgramTaskStateInput
  taskStates: [ProgramTaskStateInput!]
}

input ProgramEmailConfigInput {
  key: String
  enabled: Boolean!
  values: RSJsonNode!
}

input ProgramRewardConfigInput {
  key: String!
  name: String
  description: String
  rewardType: RewardType!
  amount: Int
  unit: String
  # Deprecated. Use unit with an ISO currency code instead.
  currency: String
  # Deprecated. Use validityDuration instead.
  monthsDiscountIsValid: Int
  validityDuration: IsoDuration
  # For display purposes only. Could hopefully be replaced.
  fuelTankType: FuelTankType
  integrationId: ID
  integrationSettings: RSJsonNode
}

input ProgramWidgetConfigInput {
  key: String!
  values: RSJsonNode!
}

input ProgramSharingConfigInput {
  redirectUrl: ProgramRedirectUrlConfigInput
  linkConfig: ProgramLinkConfigInput
}

input ProgramRedirectUrlConfigInput {
  url: String!
  fallbackUrl: String
  """
  Expiry duration for referral code cookies
  """
  cookieExpiryDuration: IsoDuration!
  rules: RSJsonNode
}

input ProgramLinkConfigInput {
  messaging: RSJsonNode
}

input ProgramTaskStateInput {
  key: String!
  invocationNumber: Long!
  status: ScheduledTaskStatus!
}

interface TranslatableAsset {
  translationInfo: TranslationInfo!
}

type TranslationInfo {
  id: TranslatableAssetId!
  translatableAsset: TranslatableAsset!
  program: Program
  programId: ID
  translatableAssetKey: String
  content: RSJsonNode
  translations: [TranslationInstance!]!
  locales: [RSLocale!]!
}

type TranslationInstance {
  id: TranslationInstanceId!
  program: Program
  programId: ID
  translatableAssetKey: String
  locale: RSLocale!
  content: RSJsonNode!
  dateCreated: RSDate
  dateModified: RSDate
}

type TranslationInstanceDeleteResult {
  deletedCount: Long!
}

input TranslationInstanceInput {
  id: TranslationInstanceId!
  content: RSJsonNode!
}

type Job {
  id: ID!
  type: JobType!
  name: String
  requester: String
  dateCreated: RSDate
  dateCompleted: RSDate
  outputFormat: DataFileFormat
  dateExpires: RSDate
  status: JobStatus!
  mailtoEmail: String
  downloadUrl(publicLink: Boolean! = false): String
  downloadErrorUrl(publicLink: Boolean! = false): String
  downloadFileRefUrl(publicLink: Boolean! = false): String
  params: RSJsonNode
  fileRef: String
  stats: JobStats
}

type JobList {
  data: [Job!]!
  count: Int!
  totalCount: Long!
}

type JobStats {
  recordsProcessed: Long!
  errors: Long!
}

enum DataFileFormat {
  CSV
  XLSX
}

type JobToken {
  token: String
}

enum JobStatus {
  PENDING
  ABORTED
  COMPLETED
}

type JobDeleteResult {
  deletedCount: Long!
}

input JobInput {
  type: JobType!
  name: String
  requester: String
  outputFormat: DataFileFormat
  mailtoEmail: String
  fileRef: String
  params: RSJsonNode
}

input JobFilterInput {
  AND: [JobFilterInput!]
  OR: [JobFilterInput!]

  id_eq: ID
  id_in: [ID!]
  type_eq: JobType
  type_ne: JobType
  dateCreated_gte: RSDate
  dateCreated_lt: RSDate
  dateCreated_timeframe: RSRelativeTimeframe
  dateCompleted_gte: RSDate
  dateCompleted_lt: RSDate
  dateCompleted_timeframe: RSRelativeTimeframe
  status_eq: JobStatus
  status_ne: JobStatus
  status_in: [JobStatus!]
}

type Segment {
  key: SegmentKey!
  name: String
  status: SegmentStatus
  dateCreated: RSDate
  dateModified: RSDate
  participantsCount: Long!
}

enum SegmentStatus {
  ACTIVE
  ARCHIVED
}

type SegmentList {
  data: [Segment!]!
  count: Int!
  totalCount: Long!
}

input SegmentInput {
  key: SegmentKey!
  name: String
  status: SegmentStatus
}

input UserEventInput {
  userId: String!
  accountId: String!
  events: [UserEventDataInput!]
}

input UserEventDataInput {
  # Deprecated. This field is ignored.
  id: ID
  key: String!
  fields: RSJsonNode
  dateTriggered: RSDate
}

type UserEventResult {
  userId: String!
  accountId: String!
  user: User
  events: [UserEventData!]!
  programTransactions: [ProgramTransaction!]
}

type UserEventData implements GraphNodeData {
  id: ID!
  userId: String!
  accountId: String!
  key: String!
  fields: RSJsonNode
  dateTriggered: RSDate
  dateReceived: RSDate
  dateProcessed: RSDate
  updatedBy: RSUpdatedBy
  moderationPreview(
    moderationInput: ModerationInput!
  ): GraphNodeModerationPreviewList!
}

type UserEventDataList {
  data: [UserEventData!]!
  count: Int!
}

input UserEventDataFilterInput {
  key: String!
  id_eq: ID
  dateTriggered_gte: RSDate
  dateTriggered_lt: RSDate
  dateReceived_gte: RSDate
  dateReceived_lt: RSDate
  dateProcessed_gte: RSDate
  dateProcessed_lt: RSDate
  fields: RSJsonNode
}

type UserEventKeyList {
  data: [String!]!
  count: Int!
}

input UserMetricInput {
  customFieldKey: String!
  name: String
  aggregateId: ID
  aggregateRules: RSJsonNode
  userEventKey: String
  dateTriggeredWindow: IsoInterval
  fieldsFilters: [GenericFieldFilterInput!]
}

type UserAggregate {
  id: String!
  name: String!
  # JSON schema
  rules: RSJsonNode
}

type UserMetric {
  customFieldKey: String!
  customField: CustomField!
  name: String!
  aggregate: UserAggregate!
  aggregateRules: RSJsonNode
  userEvent: UserEventMeta!
  dateTriggeredWindow: IsoInterval
  fieldsFilters: [GenericFieldFilter!]
}

type UserMetricList {
  data: [UserMetric!]!
  count: Int!
  totalCount: Long!
}

type UserMetricDeleteResult {
  deletedCount: Long!
}

type UserEventMeta {
  key: String!
  name: String
  fields: [String!]!
}

type CustomField {
  key: String!
  name: String
  schema: JsonSchema
}

type CustomFieldList {
  data: [CustomField!]!
  count: Int!
  totalCount: Long!
}

type RSUpdatedBy {
  initiator: RSSubject
  executor: RSSubject
}

type RSSubject {
  subjectType: RSSubjectType!
  subjectId: String!
  email: String
  user: User
  integration: TenantIntegration
}

enum RSSubjectType {
  PORTAL_USER
  DEFAULT_MACHINE
  INTEGRATION
  ADMIN
  USER
}

type UserDoNotTrackIdentifier {
  hash: String!
  dateCreated: RSDate!
}

type UserDoNotTrackIdentifierList {
  data: [UserDoNotTrackIdentifier!]!
  count: Int!
  totalCount: Long!
}

type UserDoNotTrackIdentifierDeleteResult {
  deletedCount: Long!
}

input UserAnalyticsEvent {
  # user identifier
  id: String!
  # account identifier
  accountId: String!
  # program associated with this analytics event - required (default to 'classic')
  programId: ID!
  # the type of analytic to fire
  type: UserAnalyticsEventType!
  # event metat data that will be included along with the analytic and validated via user analytic json schema
  meta: RSJsonNode!
}

enum UserAnalyticsEventType {
  USER_REFERRAL_PROGRAM_LOADED_EVENT
  USER_REFERRAL_PROGRAM_ENGAGEMENT_EVENT
}

type GenericFieldFilter {
  field: String
  operator: GenericFieldFilterOperator!
  value: RSJsonNode!
}

input GenericFieldFilterInput {
  field: String
  operator: GenericFieldFilterOperator!
  value: RSJsonNode!
}

enum GenericFieldFilterOperator {
  eq
  gt
  gte
  lt
  lte
  exists
  or
}

type PortalProject {
  id: ID!
  name: String
}

input PortalProjectInput {
  name: String
}

schema {
  query: Query
  mutation: Mutation
}`;
